---
layout: default
title: Error handling
---

When errors are found encoding or decoding streams, there are various ways of
dealing with the errors. Ogonek provides four different error-handling
strategies. Functions that take an error handler argument can often be called
without that argument; when that happens `ogonek::throw_error` is the default
used.

All error handlers are objects declared in the header
`<ogonek/error.h++>`.

---

#### `throw_error`

This strategy throws a `ogonek::unicode_error` whenever invalid data is found.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::throw_error };
// throws since s is not a valid UTF-8 sequence
// (it has an unfinished multi-byte sequence)
{% endhighlight %}

`ogonek::unicode_error` derives virtually from `std::exception` and, if
`OGONEK_BOOST_EXCEPTION` is defined, also from `boost::exception`.

---

#### `discard_errors`

This strategy discards any invalid data and proceeds as if it was not present in
the stream.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::discard_errors };
// the unfinished multi-byte sequence is discarded
// t ends up with u8"banana"
{% endhighlight %}

---

#### `replace_errors`

This strategy replaces invalid data with a replacement character. If the
encoding of the output stream supports it, the Unicode replacement character
U+FFFD
&#640;&#7431;&#7448;&#671;&#7424;&#7428;&#7431;&#7437;&#7431;&#628;&#7451;
&#7428;&#668;&#7424;&#640;&#7424;&#7428;&#7451;&#7431;&#640;. is used. Otherwise
an encoding specific character (given by the encoding `replacement_character`
member) is used.

*Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::replace_errors };
// the unfinished multi-byte sequence is replaced with U+FFFD
// t ends up with u8"bana\uFFFDna"
{% endhighlight %}

---

#### `assume_valid`

This strategy assumes the stream is valid and performs no validation. This is
useful when the stream is known to be good, for example, if it was validated
previously, or generated by a process that cannot generate invalid data. If used
on a stream with invalid data, the behaviour is undefined.

*Bad Example*:
{% highlight cpp %}
std::string s = u8"bana\x80na";
ogonek::text<ogonek::utf8> t { s, ogonek::assume_valid };
// the unfinished multi-byte sequence is ignored
// this results in undefined behaviour
{% endhighlight %}

*Good Example*:
{% highlight cpp %}
std::string s = u8"banana"; // we know for sure that s is valid
ogonek::text<ogonek::utf8> t { s, ogonek::assume_valid };
{% endhighlight %}

---

### See Also

- [Encoding](encoding.html)

